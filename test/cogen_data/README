最終テストプログラム

共通メインプログラム：
C0main.c

テストプログラム(5つ)：
ackermann.c, fib.c, pi.c, prime.c, prime5.c

[0] C0コンパイラの仕様

コマンド名はcogenとし，生成されたコードを標準出力に出力する仕様にせよ．
つまり，以下のようにしてコードが生成されなければならない．

  $ ./cogen fib.c > fib.s

[1] 走らせ方

テストプログラムを./cogenで .s に変換する.
.s と, C0main.c の両方を gcc にかけて実行可能ファイルを作る.

例えば fib.c を走らせる場合:

  $ ./cogen fib.c > fib.s
  $ gcc -o fib fib.s C0main.c 
  $ ./fib 35
  14930352
  time = 0.371720886230 sec
  cycles = 942361920

それをgccでコンパイルした結果と比べる.

  $ gcc -o fib.gcc fib.c C0main.c 
  $ ./fib.gcc 35
  14930352
  time = 0.271720886230 sec
  cycles = 542070130

最適化オプション(-O3)をつけた結果とも比べてみよ.

  $ gcc -o fib.gcc -O3 fib.c C0main.c 
  $ ./fib.gcc 35
  14930352
  time = 0.178526901058 sec
  cycles = 356151760

[2] 課題クリアの条件

./run_testを実行すると，全テストプログラムが実行され，
結果の一致不一致とプロファイリング結果が表示される．
全テストプログラムに関して，OKと出力されることがクリア条件である．
当然，cogenの実行時間は，gccの実行時間に近ければ近いほど望ましい．

  $ ./run_test


[3] 各プログラムの簡単な説明と, 与えるべき引数の目安

これらのプログラムは，与える引数によって，
実行時間を一瞬〜数十秒程度に調節できるようになっている．
./run_testしたときに出力が一致しない場合，
または実行時間が長すぎる場合には，与える引数を適宜調節してテストしてみよ．

(1) fib.c

実行方法：
./fib n
第n番目のフィボナッチ数を求める．

./run_testの引数：n=40

(2) prime.c

実行方法：
./prime n
整数n未満の素数の個数を求める．

./run_testの引数：n=10000000

(3) prime5.c

実行方法：
./prime5 n
整数n未満の5つ子素数を列挙する．

./run_testの引数：n=10000000

(4) ackermann.c

実行方法：
./ackermann n m
m未満の各整数iに対して，アッカーマン関数：ackermann(n, i)の値を出力する．

./run_testの引数：n=3, m=13

(5) pi.c

実行方法：
./pi n r s
0<=x,y,z<=rの領域にランダムな点をn個打って，
モンテカルロ法で円周率を算出する．sは乱数の種である．
nとしては10の整数倍の値を指定する．

./run_testの引数：n=100000000, r=1000, s=1
