* 文法
program :=
function-definition* end-of-file

# definition :=
#   function-definition

function-definition :=
  int identifier '(' parameter-list ')' compound-statement

parameter-list :=
    EPSILON
  | parameter ( , parameter )*

parameter :=
  int identifier

# type-expression :=
#   int 

----------------------------------------------
compound-statement :=
  '{' var-declaration* statement* '}'

statement :=
    ';'
  | continue ';'
  | break ';'
  | return equality ';'
  | compound-statement
  | if-statement
  | while-statement
  | equality ';'

var-declaration :=
  int identifier ';'

if-statement :=
  if '(' equality ')' statement ( else statement )?

while-statement :=
  while '(' equality ')' statement

----------------------------------------------

equality :=
         rel == rel
         | rel != rel
         | rel

rel :=
    expression < expression  (そのままの形を，集約後のものとして返す)
    | expression <= expression
    | expression >= expression
    | expression > expression
    | expression = expression  -> expression = expression
    | expression

expression :=
     term + expression  -> .t = term + expression
     | term - expression  -> .t = term - expression
     | term

term :=
     unary * term  -> .t = unary * term
     | unary / term  -> .t = unary / term
     | unary % term  -> .t = unary % term
     | unary

unary :=
      ! unary  ->  .t = ! unary
      | + unary
      | - unary  ->  .t = - unary
      | factor

factor :=
       id
       | '(' expression ')'
       | int-literal
       | id '(' args-list ')'  ->  call id arg1 arg2 ...

args-list :=
          (expression (, expression)*)?


* 構文主導主義で，パースしていく間に中間言語と記号表を作る
* parserはやっぱり状態機械．どこまでトークンを読んだという情報を元に動く．
  だからclassが自然かな．
* _parse*()は，全て自分の先頭のtokenをパースする．
* パースエラーを出すのは，tokenを取ったときだけ
* 各演算(multiplicative-expression, additive-exprssion)は，各々その計算結果
  の入った一時変数に置き換えられる．
  つまり，計算結果が早く出るように(早く集約するように)定義された
  multiplicative-expression
  の方が優先度を高く計算されていることになる．
* _parse*()は，全てreductionした後のトークンを返すようにしているが，test文やargs-listだけは
  わざわざトークンにするのが気持ち悪いので，文字列として返している
