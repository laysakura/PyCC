* 文法
program :=
function-definition* end-of-file

# definition :=
#   function-definition

function-definition :=
  int identifier '(' parameter-list ')' compound-statement

parameter-list :=
    EPSILON
  | parameter ( , parameter )*

parameter :=
  int identifier

# type-expression :=
#   int 

----------------------------------------------
compound-statement :=
  '{' var-declaration* statement* '}'

statement :=
    ';'
  | continue ';'
  | break ';'
  | return expression ';'
  | compound-statement
  | if-statement
  | while-statement
  | expression ';'

var-declaration :=
  int identifier ';'

if-statement :=
  if '(' expression ')' statement ( else statement )?

while-statement :=
  while '(' expression ')' statement

----------------------------------------------

expression :=
  equality-expression ( = expression )?

equality-expression :=
  relational-expression ( equality-operator relational-expression )?

equality-operator: one of
  == != 

relational-expression :=
  additive-expression ( relational-operator additive-expression )?

relational-operator: one of
  < > <= >=

additive-expression :=
  multiplicative-expression ( additive-operator multiplicative-expression )*

additive-operator: one of
  + - 

multiplicative-expression :=
  unary-expression ( multiplicative-operator unary-expression )*

multiplicative-operator: one of 
  * / %

unary-expression :=
   int-literal
 | identifier ( '(' argument-expression-list ')' )?
 | '(' expression ')'
 | unary-operator unary-expression

unary-operator: one of
  + - !

argument-expression-list :=
   EPSILON
 | expression ( , expression )*


* 構文主導主義で，パースしていく間に中間言語と記号表を作る
* parserはやっぱり状態機械．どこまでトークンを読んだという情報を元に動く．
  だからclassが自然かな．
* _parse*()は，全て自分の先頭のtokenをパースする．
* パースエラーを出すのは，tokenを取ったときだけ
* 各演算(multiplicative-expression, additive-exprssion)は，各々その計算結果
  の入った一時変数に置き換えられる．
  つまり，計算結果が早く出るように(早く集約するように)定義された
  multiplicative-expression
  の方が優先度を高く計算されていることになる．
